//! Traits for aggregation
//!
//! This module provides a two-level aggregation system:
//!
//! ## Field-level aggregation: [`AggregateValue`]
//!
//! Defines how individual field values are merged. For example, [`crate::value::Sum`] sums values,
//! while `Histogram` collects values into buckets. This trait enables compile-time type resolution:
//!
//! ```rust
//! use metrique_aggregation::value::Sum;
//! use metrique_aggregation::traits::AggregateValue;
//! type AggregatedType = <Sum as AggregateValue<u64>>::Aggregated;
//! //                     ^^^                   ^^
//! //                     Aggregation strategy  input type
//! ```
//!
//! ## Entry-level aggregation: [`AggregateEntry`]
//!
//! Defines how entire metric entries are merged together. Implement this trait to aggregate
//! complete metric structs, not just individual fields.
//!
//! ## The [`Aggregate`] wrapper
//!
//! [`Aggregate<T>`] is the simplest way to aggregate data, typically used as a field in a larger struct.
//! It wraps an aggregated value and tracks the number of samples merged.

use metrique_core::{CloseEntry, CloseValue};
use std::hash::Hash;

/// Defines how individual field values are aggregated.
///
/// This trait operates at the field level, not the entry level. Each aggregation
/// strategy (Counter, Histogram, etc.) implements this trait for the types it can aggregate.
///
/// # Type Parameters
///
/// - `T`: The type of value being aggregated
///
/// # Associated Types
///
/// - `Aggregated`: The accumulated type (often same as `T`, but can differ for histograms)
///
/// # Example
///
/// ```rust
/// use metrique_aggregation::traits::AggregateValue;
/// use metrique_core::CloseValue;
///
/// // Average tracks sum and count to compute average
/// pub struct Avg;
///
/// pub struct AvgAccumulator {
///     sum: f64,
///     count: u64,
/// }
///
/// impl CloseValue for AvgAccumulator {
///     type Closed = f64;
///
///     fn close(self) -> f64 {
///         if self.count == 0 {
///             0.0
///         } else {
///             self.sum / self.count as f64
///         }
///     }
/// }
///
/// impl AggregateValue<f64> for Avg {
///     type Aggregated = AvgAccumulator;
///
///     fn add_value(accum: &mut Self::Aggregated, value: f64) {
///         accum.sum += value;
///         accum.count += 1;
///     }
/// }
/// ```
pub trait AggregateValue<T> {
    /// The accumulated type (often same as T, but can differ for histograms).
    type Aggregated;

    /// Aggregate a value into the accumulator.
    fn add_value(accum: &mut Self::Aggregated, value: T);
}

/// An addition to AggregateEntry for entries than can be aggregated using a
/// reference to Source, instead of owning
pub trait AggregateEntryRef: AggregateEntry {
    /// Merge a given entry into the aggregate by reference
    fn merge_entry_ref(accum: &mut Self::Aggregated, entry: &Self::Source);
}

/// Strategy for aggregating metrics
pub trait AggregateEntry {
    /// Source is the type of metrics being aggregated on — the "raw" metrics
    ///
    /// If you are manually implementing this trait, it will typically be `Self`
    ///
    /// If this trait is being generated by the [`aggregate`](crate::aggregate) proc macro, then
    /// it defaults to the "entry" type (which you obtain by calling `CloseValue::close(v)`)
    type Source: Send + 'static;

    /// Aggregated type
    type Aggregated: Send + CloseEntry;

    /// Aggregation Key. For structs with no key, you typically use `()`
    type Key<'a>: Send + Hash + Eq;

    /// Convert the Key to a non-borrowed version of the key so it can be stored
    fn static_key<'a>(key: Self::Key<'a>) -> Self::Key<'static>;

    /// Merge a given entry into the Aggregate
    fn merge_entry(accum: &mut Self::Aggregated, entry: Self::Source);

    /// Create a new, empty, aggregated entry for a given key
    fn new_aggregated<'a>(key: &Self::Key<'a>) -> Self::Aggregated;

    /// Returns the key for a given aggregate
    fn key(source: &Self::Source) -> Self::Key<'_>;
}

/// Aggregated allows inline-aggregation of a metric
///
/// Aggregated is simple — more complex designs allow `append_on_drop` via a queue
/// or guard. Aggregate is a minimal version.
pub struct Aggregate<T: AggregateEntry> {
    aggregated: T::Aggregated,
    num_samples: usize,
}

impl<T: AggregateEntry> CloseValue for Aggregate<T>
where
    T::Aggregated: CloseValue,
{
    type Closed = <T::Aggregated as CloseValue>::Closed;

    fn close(self) -> <Self as CloseValue>::Closed {
        self.aggregated.close()
    }
}

impl<T: AggregateEntry> Aggregate<T> {
    /// Add a new entry into this aggregate
    pub fn add_raw(&mut self, entry: T::Source) {
        self.num_samples += 1;
        T::merge_entry(&mut self.aggregated, entry);
    }

    /// Add a new entry into this aggregate
    ///
    /// This method is used when `Source` is the "closed" version. If you are using
    /// `#[aggregate(raw)]`, use `add_raw` to add the type directly
    pub fn add(&mut self, entry: T)
    where
        T: CloseValue<Closed = T::Source>,
    {
        self.add_raw(entry.close());
    }

    /// Creates a `Aggreate` that is initialized to a given value
    pub fn new(value: T::Aggregated) -> Self {
        Self {
            aggregated: value,
            num_samples: 0,
        }
    }
}

impl<T: AggregateEntry> Default for Aggregate<T>
where
    T::Aggregated: Default,
{
    fn default() -> Self {
        Self {
            aggregated: T::Aggregated::default(),
            num_samples: 0,
        }
    }
}
