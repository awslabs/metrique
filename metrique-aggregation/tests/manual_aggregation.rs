//! Example demonstrating manual implementation of the AggregateStrategy traits.

use assert2::check;
use metrique::unit::Millisecond;
use metrique::unit_of_work::metrics;
use metrique::writer::value::ToString;
use metrique_aggregation::histogram::{Histogram, SortAndMerge};
use metrique_aggregation::keyed_sink::{KeyedAggregator, WorkerSink};
use metrique_aggregation::sink::MergeOnDrop;
use metrique_aggregation::traits::{AggregateStrategy, Key, Merge, RootSink};
use metrique_writer::test_util::test_entry_sink;
use std::borrow::Cow;
use std::time::Duration;

#[metrics]
pub struct ApiCall {
    endpoint: String,
    status_code: usize,

    #[metrics(unit = Millisecond)]
    latency: Option<Duration>,
}

// Manually implement the merge method (normally generated by #[aggregate(raw)])
impl ApiCall {
    pub fn merge<Sink: RootSink<Self>>(self, sink: Sink) -> MergeOnDrop<Self, Sink> {
        MergeOnDrop::new(self, sink)
    }
}

// Key is a metrics struct
#[derive(Clone, Hash, PartialEq, Eq)]
#[metrics(emf::dimension_sets = [["endpoint", "status_code"]])]
pub struct ApiCallKey<'a> {
    endpoint: Cow<'a, String>,
    #[metrics(format = ToString)]
    status_code: Cow<'a, usize>,
}

// Implement Merge for ApiCall (raw mode - merge the user type directly)
impl Merge for ApiCall {
    type Merged = AggregatedApiCall;
    type MergeConfig = ();

    fn new_merged(_conf: &Self::MergeConfig) -> Self::Merged {
        Self::Merged::default()
    }

    fn merge(accum: &mut Self::Merged, input: Self) {
        if let Some(latency) = input.latency {
            accum.latency.add_value(latency);
        }
    }
}

#[metrics]
#[derive(Default)]
pub struct AggregatedApiCall {
    #[metrics(unit = Millisecond)]
    latency: Histogram<Duration, SortAndMerge>,
}

// Key extraction for ApiCall
pub struct ApiCallByEndpointStatusCode;

impl Key<ApiCall> for ApiCallByEndpointStatusCode {
    type Key<'a> = ApiCallKey<'a>;

    fn from_source(source: &ApiCall) -> Self::Key<'_> {
        ApiCallKey {
            endpoint: Cow::Borrowed(&source.endpoint),
            status_code: Cow::Borrowed(&source.status_code),
        }
    }

    fn static_key<'a>(key: &Self::Key<'a>) -> Self::Key<'static> {
        ApiCallKey {
            endpoint: Cow::Owned(key.endpoint.clone().into_owned()),
            status_code: Cow::Owned(key.status_code.clone().into_owned()),
        }
    }

    fn static_key_matches<'a>(owned: &Self::Key<'static>, borrowed: &Self::Key<'a>) -> bool {
        owned == borrowed
    }
}

impl AggregateStrategy for ApiCall {
    type Source = ApiCall;
    type Key = ApiCallByEndpointStatusCode;
}

#[tokio::test]
async fn test_manual_aggregation_strategy() {
    let test_sink = test_entry_sink();
    let keyed_aggregator: KeyedAggregator<ApiCall> = KeyedAggregator::new(test_sink.sink);
    let sink = WorkerSink::new(keyed_aggregator, Duration::from_millis(100));

    let mut api_call = ApiCall {
        endpoint: "GetItem".to_string(),
        latency: None,
        status_code: 200,
    }
    .merge(sink.clone());
    api_call.latency = Some(Duration::from_millis(100));

    drop(api_call);
    sink.flush().await;

    let entry = test_sink.inspector.entries()[0].clone();
    check!(entry.metrics["latency"].flatten_and_sort() == &[100.0]);
}
