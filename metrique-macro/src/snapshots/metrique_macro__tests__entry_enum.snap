---
source: metrique-macro/src/lib.rs
expression: parsed_file
---
struct Nested {
    value: u32,
}
#[doc(hidden)]
#[allow(clippy::type_complexity)]
pub struct NestedEntry {
    #[deprecated(
        note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
    )]
    #[doc(hidden)]
    value: <u32 as metrique::CloseValue>::Closed,
}
const _: () = {
    #[expect(deprecated)]
    impl<NS: ::metrique::NameStyle> ::metrique::InflectableEntry<NS> for NestedEntry {
        fn write<'__metrique_write>(
            &'__metrique_write self,
            writer: &mut impl ::metrique::writer::EntryWriter<'__metrique_write>,
        ) {
            ::metrique::writer::EntryWriter::value(
                writer,
                {
                    struct ValuePreserve;
                    impl ::metrique::concat::ConstStr for ValuePreserve {
                        const VAL: &'static str = "value";
                    }
                    struct ValueKebab;
                    impl ::metrique::concat::ConstStr for ValueKebab {
                        const VAL: &'static str = "value";
                    }
                    struct ValuePascal;
                    impl ::metrique::concat::ConstStr for ValuePascal {
                        const VAL: &'static str = "Value";
                    }
                    struct ValueSnake;
                    impl ::metrique::concat::ConstStr for ValueSnake {
                        const VAL: &'static str = "value";
                    }
                    ::metrique::concat::const_str_value::<
                        <NS as ::metrique::NameStyle>::Inflect<
                            ValuePreserve,
                            ValuePascal,
                            ValueSnake,
                            ValueKebab,
                        >,
                    >()
                },
                &self.value,
            );
        }
        fn sample_group(
            &self,
        ) -> impl ::std::iter::Iterator<
            Item = (::std::borrow::Cow<'static, str>, ::std::borrow::Cow<'static, str>),
        > {
            ::std::iter::empty()
        }
    }
};
impl metrique::CloseValue for &'_ Nested {
    type Closed = NestedEntry;
    fn close(self) -> Self::Closed {
        #[allow(deprecated)]
        NestedEntry {
            value: metrique::CloseValue::close(&self.value),
        }
    }
}
impl metrique::CloseValue for Nested {
    type Closed = NestedEntry;
    fn close(self) -> Self::Closed {
        <&Self>::close(&self)
    }
}

enum Status {
    Active { count: u32, latency: u64 },
    Pending(Nested),
    Multi(Nested, u32),
}
#[doc(hidden)]
pub enum StatusEntry {
    #[deprecated(
        note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
    )]
    #[doc(hidden)]
    Active {
        #[deprecated(
            note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
        )]
        #[doc(hidden)]
        count: <u32 as metrique::CloseValue>::Closed,
        #[deprecated(
            note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
        )]
        #[doc(hidden)]
        latency: <<u64 as metrique::CloseValue>::Closed as ::metrique::unit::AttachUnit>::Output<
            metrique::writer::unit::Millisecond,
        >,
    },
    #[deprecated(
        note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
    )]
    #[doc(hidden)]
    Pending(<Nested as metrique::CloseValue>::Closed),
    #[deprecated(
        note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
    )]
    #[doc(hidden)]
    Multi(
        <Nested as metrique::CloseValue>::Closed,
        <u32 as metrique::CloseValue>::Closed,
    ),
}
const _: () = {
    enum StatusEntrySampleGroupIter<V0, V1, V2> {
        V0(V0),
        V1(V1),
        V2(V2),
    }
    impl<
        V0: ::std::iter::Iterator<
                Item = (
                    ::std::borrow::Cow<'static, str>,
                    ::std::borrow::Cow<'static, str>,
                ),
            >,
        V1: ::std::iter::Iterator<
                Item = (
                    ::std::borrow::Cow<'static, str>,
                    ::std::borrow::Cow<'static, str>,
                ),
            >,
        V2: ::std::iter::Iterator<
                Item = (
                    ::std::borrow::Cow<'static, str>,
                    ::std::borrow::Cow<'static, str>,
                ),
            >,
    > ::std::iter::Iterator for StatusEntrySampleGroupIter<V0, V1, V2> {
        type Item = (::std::borrow::Cow<'static, str>, ::std::borrow::Cow<'static, str>);
        fn next(&mut self) -> ::std::option::Option<Self::Item> {
            match self {
                StatusEntrySampleGroupIter::V0(iter) => iter.next(),
                StatusEntrySampleGroupIter::V1(iter) => iter.next(),
                StatusEntrySampleGroupIter::V2(iter) => iter.next(),
            }
        }
    }
    #[expect(deprecated)]
    impl<NS: ::metrique::NameStyle> ::metrique::InflectableEntry<NS> for StatusEntry {
        fn write<'__metrique_write>(
            &'__metrique_write self,
            writer: &mut impl ::metrique::writer::EntryWriter<'__metrique_write>,
        ) {
            #[allow(deprecated)]
            match self {
                StatusEntry::Active { count, latency } => {
                    ::metrique::writer::EntryWriter::value(
                        writer,
                        {
                            struct CountPreserve;
                            impl ::metrique::concat::ConstStr for CountPreserve {
                                const VAL: &'static str = "count";
                            }
                            struct CountKebab;
                            impl ::metrique::concat::ConstStr for CountKebab {
                                const VAL: &'static str = "count";
                            }
                            struct CountPascal;
                            impl ::metrique::concat::ConstStr for CountPascal {
                                const VAL: &'static str = "Count";
                            }
                            struct CountSnake;
                            impl ::metrique::concat::ConstStr for CountSnake {
                                const VAL: &'static str = "count";
                            }
                            ::metrique::concat::const_str_value::<
                                <NS as ::metrique::NameStyle>::Inflect<
                                    CountPreserve,
                                    CountPascal,
                                    CountSnake,
                                    CountKebab,
                                >,
                            >()
                        },
                        count,
                    );
                    ::metrique::writer::EntryWriter::value(
                        writer,
                        {
                            struct LatencyPreserve;
                            impl ::metrique::concat::ConstStr for LatencyPreserve {
                                const VAL: &'static str = "latency";
                            }
                            struct LatencyKebab;
                            impl ::metrique::concat::ConstStr for LatencyKebab {
                                const VAL: &'static str = "latency";
                            }
                            struct LatencyPascal;
                            impl ::metrique::concat::ConstStr for LatencyPascal {
                                const VAL: &'static str = "Latency";
                            }
                            struct LatencySnake;
                            impl ::metrique::concat::ConstStr for LatencySnake {
                                const VAL: &'static str = "latency";
                            }
                            ::metrique::concat::const_str_value::<
                                <NS as ::metrique::NameStyle>::Inflect<
                                    LatencyPreserve,
                                    LatencyPascal,
                                    LatencySnake,
                                    LatencyKebab,
                                >,
                            >()
                        },
                        latency,
                    );
                }
                StatusEntry::Pending(v0) => {
                    ::metrique::InflectableEntry::<NS>::write(v0, writer);
                }
                StatusEntry::Multi(v0, v1) => {
                    ::metrique::InflectableEntry::<NS>::write(v0, writer);
                }
            }
        }
        fn sample_group(
            &self,
        ) -> impl ::std::iter::Iterator<
            Item = (::std::borrow::Cow<'static, str>, ::std::borrow::Cow<'static, str>),
        > {
            match self {
                StatusEntry::Active { .. } => {
                    StatusEntrySampleGroupIter::V0(::std::iter::empty())
                }
                StatusEntry::Pending(v0) => {
                    StatusEntrySampleGroupIter::V1(
                        ::metrique::InflectableEntry::<NS>::sample_group(v0),
                    )
                }
                StatusEntry::Multi(v0, v1) => {
                    StatusEntrySampleGroupIter::V2(
                        ::metrique::InflectableEntry::<NS>::sample_group(v0),
                    )
                }
            }
        }
    }
};
impl metrique::CloseValue for &'_ Status {
    type Closed = StatusEntry;
    fn close(self) -> Self::Closed {
        #[allow(deprecated)]
        match self {
            Status::Active { count, latency } => {
                StatusEntry::Active {
                    count: metrique::CloseValue::close(count),
                    latency: metrique::CloseValue::close(latency).into(),
                }
            }
            Status::Pending(v0) => {
                StatusEntry::Pending(::metrique::CloseValue::close(v0))
            }
            Status::Multi(v0, v1) => {
                StatusEntry::Multi(
                    ::metrique::CloseValue::close(v0),
                    ::metrique::CloseValue::close(v1),
                )
            }
        }
    }
}
impl metrique::CloseValue for Status {
    type Closed = StatusEntry;
    fn close(self) -> Self::Closed {
        <&Self>::close(&self)
    }
}
impl ::std::convert::From<&'_ Status> for &'static str {
    fn from(value: &Status) -> Self {
        #[allow(deprecated)]
        match value {
            Status::Active { .. } => "Active",
            Status::Pending(_) => "Pending",
            Status::Multi(_, _) => "Multi",
        }
    }
}
impl ::std::convert::From<Status> for &'static str {
    fn from(value: Status) -> Self {
        <&str as ::std::convert::From<&_>>::from(&value)
    }
}
impl ::metrique::writer::core::SampleGroup for Status {
    fn as_sample_group(&self) -> ::std::borrow::Cow<'static, str> {
        ::std::borrow::Cow::Borrowed(::std::convert::Into::<&str>::into(self))
    }
}

enum Operation {
    Read { bytes: u64 },
    Write(Nested),
}
#[doc(hidden)]
pub enum OperationEntry {
    #[deprecated(
        note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
    )]
    #[doc(hidden)]
    Read {
        #[deprecated(
            note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
        )]
        #[doc(hidden)]
        bytes: <u64 as metrique::CloseValue>::Closed,
    },
    #[deprecated(
        note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
    )]
    #[doc(hidden)]
    Write(<Nested as metrique::CloseValue>::Closed),
}
const _: () = {
    enum OperationEntrySampleGroupIter<V0, V1> {
        V0(V0),
        V1(V1),
    }
    impl<
        V0: ::std::iter::Iterator<
                Item = (
                    ::std::borrow::Cow<'static, str>,
                    ::std::borrow::Cow<'static, str>,
                ),
            >,
        V1: ::std::iter::Iterator<
                Item = (
                    ::std::borrow::Cow<'static, str>,
                    ::std::borrow::Cow<'static, str>,
                ),
            >,
    > ::std::iter::Iterator for OperationEntrySampleGroupIter<V0, V1> {
        type Item = (::std::borrow::Cow<'static, str>, ::std::borrow::Cow<'static, str>);
        fn next(&mut self) -> ::std::option::Option<Self::Item> {
            match self {
                OperationEntrySampleGroupIter::V0(iter) => iter.next(),
                OperationEntrySampleGroupIter::V1(iter) => iter.next(),
            }
        }
    }
    #[expect(deprecated)]
    impl<NS: ::metrique::NameStyle> ::metrique::InflectableEntry<NS> for OperationEntry {
        fn write<'__metrique_write>(
            &'__metrique_write self,
            writer: &mut impl ::metrique::writer::EntryWriter<'__metrique_write>,
        ) {
            #[allow(deprecated)]
            match self {
                OperationEntry::Read { bytes } => {
                    ::metrique::writer::EntryWriter::value(
                        writer,
                        {
                            struct BytesPreserve;
                            impl ::metrique::concat::ConstStr for BytesPreserve {
                                const VAL: &'static str = "bytes";
                            }
                            struct BytesKebab;
                            impl ::metrique::concat::ConstStr for BytesKebab {
                                const VAL: &'static str = "bytes";
                            }
                            struct BytesPascal;
                            impl ::metrique::concat::ConstStr for BytesPascal {
                                const VAL: &'static str = "Bytes";
                            }
                            struct BytesSnake;
                            impl ::metrique::concat::ConstStr for BytesSnake {
                                const VAL: &'static str = "bytes";
                            }
                            ::metrique::concat::const_str_value::<
                                <NS as ::metrique::NameStyle>::Inflect<
                                    BytesPreserve,
                                    BytesPascal,
                                    BytesSnake,
                                    BytesKebab,
                                >,
                            >()
                        },
                        bytes,
                    );
                }
                OperationEntry::Write(v0) => {
                    ::metrique::InflectableEntry::<NS>::write(v0, writer);
                }
            }
        }
        fn sample_group(
            &self,
        ) -> impl ::std::iter::Iterator<
            Item = (::std::borrow::Cow<'static, str>, ::std::borrow::Cow<'static, str>),
        > {
            match self {
                OperationEntry::Read { .. } => {
                    OperationEntrySampleGroupIter::V0(::std::iter::empty())
                }
                OperationEntry::Write(v0) => {
                    OperationEntrySampleGroupIter::V1(
                        ::metrique::InflectableEntry::<NS>::sample_group(v0),
                    )
                }
            }
        }
    }
};
impl metrique::CloseValue for Operation {
    type Closed = OperationEntry;
    fn close(self) -> Self::Closed {
        #[allow(deprecated)]
        match self {
            Operation::Read { bytes } => {
                OperationEntry::Read {
                    bytes: metrique::CloseValue::close(bytes),
                }
            }
            Operation::Write(v0) => {
                OperationEntry::Write(::metrique::CloseValue::close(v0))
            }
        }
    }
}
impl ::std::convert::From<&'_ Operation> for &'static str {
    fn from(value: &Operation) -> Self {
        #[allow(deprecated)]
        match value {
            Operation::Read { .. } => "Read",
            Operation::Write(_) => "Write",
        }
    }
}
impl ::std::convert::From<Operation> for &'static str {
    fn from(value: Operation) -> Self {
        <&str as ::std::convert::From<&_>>::from(&value)
    }
}
impl ::metrique::writer::core::SampleGroup for Operation {
    fn as_sample_group(&self) -> ::std::borrow::Cow<'static, str> {
        ::std::borrow::Cow::Borrowed(::std::convert::Into::<&str>::into(self))
    }
}
#[doc = concat!(
    "Metrics guard returned from [`", "Operation",
    "::append_on_drop`], closes the entry and appends the metrics to a sink when dropped."
)]
type OperationGuard<Q = ::metrique::DefaultSink> = ::metrique::AppendAndCloseOnDrop<
    Operation,
    Q,
>;
#[doc = concat!(
    "Metrics handle returned from [`", "OperationGuard",
    "::handle`], similar to an `Arc<", "OperationGuard", ">`."
)]
type OperationHandle<Q = ::metrique::DefaultSink> = ::metrique::AppendAndCloseOnDropHandle<
    Operation,
    Q,
>;
impl Operation {
    ///Creates an AppendAndCloseOnDrop that will be automatically appended to `sink` on drop.
    fn append_on_drop<
        Q: ::metrique::writer::EntrySink<::metrique::RootEntry<OperationEntry>> + Send
            + Sync + 'static,
    >(self, sink: Q) -> OperationGuard<Q> {
        ::metrique::append_and_close(self, sink)
    }
}
