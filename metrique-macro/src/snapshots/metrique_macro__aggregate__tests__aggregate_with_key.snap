---
source: metrique-macro/src/aggregate.rs
expression: parsed_file
---
#[metrics]
struct AggregatedApiCallWithOperation {
    endpoint: String,
    #[metrics(unit = Millisecond)]
    latency: <Histogram<
        Duration,
    > as metrique_aggregation::__macro_plumbing::AggregateValue<Duration>>::Aggregated,
}
impl metrique_aggregation::__macro_plumbing::MergeOnDropExt for ApiCallWithOperation {}
impl metrique_aggregation::__macro_plumbing::AggregateEntry for ApiCallWithOperation {
    type Source = Self;
    type Aggregated = AggregatedApiCallWithOperation;
    type Key<'a> = ::std::borrow::Cow<'a, String>;
    fn static_key<'a>(key: Self::Key<'a>) -> Self::Key<'static> {
        ::std::borrow::Cow::Owned(key.into_owned())
    }
    fn merge_entry(accum: &mut Self::Aggregated, entry: Self::Source) {
        #[allow(deprecated)]
        <Histogram<
            Duration,
        > as metrique_aggregation::__macro_plumbing::AggregateValue<
            Duration,
        >>::add_value(&mut accum.latency, entry.latency);
    }
    fn new_aggregated<'a>(key: &Self::Key<'a>) -> Self::Aggregated {
        AggregatedApiCallWithOperation {
            endpoint: key.clone().into_owned(),
            latency: Default::default(),
        }
    }
    fn key(source: &Self::Source) -> Self::Key<'_> {
        #[allow(deprecated)] ::std::borrow::Cow::Borrowed(&source.endpoint)
    }
}
#[metrics]
struct ApiCallWithOperation {
    endpoint: String,
    #[metrics(unit = Millisecond)]
    latency: Duration,
}
