---
source: metrique-macro/src/lib.rs
expression: parsed_file
---
struct RequestMetrics { operation : & 'static str , status_code : u16 , request_count : u64 , latency_ms : u64 } # [doc (hidden)] pub struct RequestMetricsEntry { # [deprecated (note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`")] # [doc (hidden)] operation : < & 'static str as metrique :: CloseValue > :: Closed , # [deprecated (note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`")] # [doc (hidden)] status_code : < u16 as metrique :: CloseValue > :: Closed , # [deprecated (note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`")] # [doc (hidden)] request_count : < u64 as metrique :: CloseValue > :: Closed , # [deprecated (note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`")] # [doc (hidden)] latency_ms : < u64 as metrique :: CloseValue > :: Closed } const _ : () = { # [expect (deprecated)] impl < NS : :: metrique :: NameStyle > :: metrique :: InflectableEntry < NS > for RequestMetricsEntry { fn write < 'a > (& 'a self , writer : & mut impl :: metrique :: writer :: EntryWriter < 'a >) { :: metrique :: writer :: EntryWriter :: value (writer , { # [allow (non_camel_case_types)] struct operationPreserve ; impl :: metrique :: concat :: ConstStr for operationPreserve { const VAL : & 'static str = "operation" ; } # [allow (non_camel_case_types)] struct operationKebab ; impl :: metrique :: concat :: ConstStr for operationKebab { const VAL : & 'static str = "operation" ; } # [allow (non_camel_case_types)] struct operationPascal ; impl :: metrique :: concat :: ConstStr for operationPascal { const VAL : & 'static str = "Operation" ; } # [allow (non_camel_case_types)] struct operationSnake ; impl :: metrique :: concat :: ConstStr for operationSnake { const VAL : & 'static str = "operation" ; } :: metrique :: concat :: const_str_value :: < < NS as :: metrique :: NameStyle > :: Inflect < operationPreserve , operationPascal , operationSnake , operationKebab > > () } , & self . operation) ; :: metrique :: writer :: EntryWriter :: value (writer , { # [allow (non_camel_case_types)] struct status_codePreserve ; impl :: metrique :: concat :: ConstStr for status_codePreserve { const VAL : & 'static str = "status_code" ; } # [allow (non_camel_case_types)] struct status_codeKebab ; impl :: metrique :: concat :: ConstStr for status_codeKebab { const VAL : & 'static str = "status-code" ; } # [allow (non_camel_case_types)] struct status_codePascal ; impl :: metrique :: concat :: ConstStr for status_codePascal { const VAL : & 'static str = "StatusCode" ; } # [allow (non_camel_case_types)] struct status_codeSnake ; impl :: metrique :: concat :: ConstStr for status_codeSnake { const VAL : & 'static str = "status_code" ; } :: metrique :: concat :: const_str_value :: < < NS as :: metrique :: NameStyle > :: Inflect < status_codePreserve , status_codePascal , status_codeSnake , status_codeKebab > > () } , & self . status_code) ; :: metrique :: writer :: EntryWriter :: value (writer , { # [allow (non_camel_case_types)] struct request_countPreserve ; impl :: metrique :: concat :: ConstStr for request_countPreserve { const VAL : & 'static str = "request_count" ; } # [allow (non_camel_case_types)] struct request_countKebab ; impl :: metrique :: concat :: ConstStr for request_countKebab { const VAL : & 'static str = "request-count" ; } # [allow (non_camel_case_types)] struct request_countPascal ; impl :: metrique :: concat :: ConstStr for request_countPascal { const VAL : & 'static str = "RequestCount" ; } # [allow (non_camel_case_types)] struct request_countSnake ; impl :: metrique :: concat :: ConstStr for request_countSnake { const VAL : & 'static str = "request_count" ; } :: metrique :: concat :: const_str_value :: < < NS as :: metrique :: NameStyle > :: Inflect < request_countPreserve , request_countPascal , request_countSnake , request_countKebab > > () } , & self . request_count) ; :: metrique :: writer :: EntryWriter :: value (writer , { # [allow (non_camel_case_types)] struct latency_msPreserve ; impl :: metrique :: concat :: ConstStr for latency_msPreserve { const VAL : & 'static str = "latency_ms" ; } # [allow (non_camel_case_types)] struct latency_msKebab ; impl :: metrique :: concat :: ConstStr for latency_msKebab { const VAL : & 'static str = "latency-ms" ; } # [allow (non_camel_case_types)] struct latency_msPascal ; impl :: metrique :: concat :: ConstStr for latency_msPascal { const VAL : & 'static str = "LatencyMs" ; } # [allow (non_camel_case_types)] struct latency_msSnake ; impl :: metrique :: concat :: ConstStr for latency_msSnake { const VAL : & 'static str = "latency_ms" ; } :: metrique :: concat :: const_str_value :: < < NS as :: metrique :: NameStyle > :: Inflect < latency_msPreserve , latency_msPascal , latency_msSnake , latency_msKebab > > () } , & self . latency_ms) ; } fn sample_group (& self) -> impl :: std :: iter :: Iterator < Item = (:: std :: borrow :: Cow < 'static , str > , :: std :: borrow :: Cow < 'static , str >) > { :: std :: iter :: empty () } } } ; impl metrique :: CloseValue for RequestMetrics { type Closed = RequestMetricsEntry ; fn close (self) -> Self :: Closed { # [allow (deprecated)] RequestMetricsEntry { operation : metrique :: CloseValue :: close (self . operation) , status_code : metrique :: CloseValue :: close (self . status_code) , request_count : metrique :: CloseValue :: close (self . request_count) , latency_ms : metrique :: CloseValue :: close (self . latency_ms) , } } } # [derive (Debug)] struct AggregatedRequestMetrics { key : (& 'static str , u16) , "request_count" : < Counter as :: metrique :: writer :: merge :: AggregateValue < u64 >> :: Aggregated , "latency_ms" : < Histogram as :: metrique :: writer :: merge :: AggregateValue < u64 >> :: Aggregated , entry_count : usize } impl :: metrique :: writer :: merge :: AggregatableEntry for RequestMetrics { type Key = (& 'static str , u16) ; type Aggregated = AggregatedRequestMetrics ; fn new_aggregated (key : Self :: Key) -> Self :: Aggregated { AggregatedRequestMetrics { key , "request_count" : < Counter as :: metrique :: writer :: merge :: AggregateValue < _ >> :: init () , "latency_ms" : < Histogram as :: metrique :: writer :: merge :: AggregateValue < _ >> :: init () , entry_count : 0 , } } fn key (& self) -> Self :: Key { (self . "operation" , self . "status_code") } } impl :: metrique :: writer :: merge :: AggregatedEntry for AggregatedRequestMetrics { type Key = (& 'static str , u16) ; type Source = RequestMetrics ; fn aggregate_into (& mut self , entry : & Self :: Source) { < Counter as :: metrique :: writer :: merge :: AggregateValue < _ >> :: aggregate (& mut self . "request_count" , & entry . "request_count") ; < Histogram as :: metrique :: writer :: merge :: AggregateValue < _ >> :: aggregate (& mut self . "latency_ms" , & entry . "latency_ms") ; self . entry_count += 1 ; } fn count (& self) -> usize { self . entry_count } } impl :: metrique :: writer :: Entry for AggregatedRequestMetrics { fn write < 'a > (& 'a self , writer : & mut impl :: metrique :: writer :: EntryWriter < 'a >) { writer . value ("Operation" , & self . key . 0) ; writer . value ("StatusCode" , & self . key . 1) ; writer . value ("RequestCount" , & self . "request_count") ; writer . value ("LatencyMs" , & self . "latency_ms") ; writer . value ("AggregatedEntryCount" , & (self . entry_count as u64)) ; } fn sample_group (& self) -> impl Iterator < Item = (:: std :: borrow :: Cow < 'static , str > , :: std :: borrow :: Cow < 'static , str >) > { [("Operation" . into () , self . key . 0 . to_string () . into ()) , ("StatusCode" . into () , self . key . 1 . to_string () . into ())] . into_iter () } }
