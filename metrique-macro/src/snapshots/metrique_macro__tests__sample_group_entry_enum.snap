---
source: metrique-macro/src/lib.rs
expression: parsed_file
---
enum Operation {
    Read,
    Write,
}
#[doc(hidden)]
enum OperationValue {
    #[deprecated(
        note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
    )]
    #[doc(hidden)]
    Read,
    #[deprecated(
        note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
    )]
    #[doc(hidden)]
    Write,
}
impl ::std::convert::From<&'_ OperationValue> for &'static str {
    fn from(value: &OperationValue) -> Self {
        #[allow(deprecated)]
        match value {
            OperationValue::Read => "Read",
            OperationValue::Write => "Write",
        }
    }
}
impl ::std::convert::From<OperationValue> for &'static str {
    fn from(value: OperationValue) -> Self {
        <&str as ::std::convert::From<&_>>::from(&value)
    }
}
impl ::metrique::writer::core::SampleGroup for OperationValue {
    fn as_sample_group(&self) -> ::std::borrow::Cow<'static, str> {
        ::std::borrow::Cow::Borrowed(::std::convert::Into::<&str>::into(self))
    }
}
impl ::metrique::writer::Value for OperationValue {
    fn write(&self, writer: impl ::metrique::writer::ValueWriter) {
        writer.string(::std::convert::Into::<&str>::into(self));
    }
}
impl metrique::CloseValue for &'_ Operation {
    type Closed = OperationValue;
    fn close(self) -> Self::Closed {
        #[allow(deprecated)]
        match self {
            Operation::Read => OperationValue::Read,
            Operation::Write => OperationValue::Write,
        }
    }
}
impl metrique::CloseValue for Operation {
    type Closed = OperationValue;
    fn close(self) -> Self::Closed {
        <&Self>::close(&self)
    }
}
impl ::std::convert::From<&'_ Operation> for &'static str {
    fn from(value: &Operation) -> Self {
        #[allow(deprecated)]
        match value {
            Operation::Read => "Read",
            Operation::Write => "Write",
        }
    }
}
impl ::std::convert::From<Operation> for &'static str {
    fn from(value: Operation) -> Self {
        <&str as ::std::convert::From<&_>>::from(&value)
    }
}
impl ::metrique::writer::core::SampleGroup for Operation {
    fn as_sample_group(&self) -> ::std::borrow::Cow<'static, str> {
        ::std::borrow::Cow::Borrowed(::std::convert::Into::<&str>::into(self))
    }
}

struct Metadata {
    operation: Operation,
    request_id: String,
}
#[doc(hidden)]
struct MetadataEntry {
    #[deprecated(
        note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
    )]
    #[doc(hidden)]
    operation: <Operation as metrique::CloseValue>::Closed,
    #[deprecated(
        note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
    )]
    #[doc(hidden)]
    request_id: <String as metrique::CloseValue>::Closed,
}
const _: () = {
    #[expect(deprecated)]
    impl<NS: ::metrique::NameStyle> ::metrique::InflectableEntry<NS> for MetadataEntry {
        fn write<'a>(&'a self, writer: &mut impl ::metrique::writer::EntryWriter<'a>) {
            ::metrique::writer::EntryWriter::value(
                writer,
                {
                    #[allow(non_camel_case_types)]
                    struct operationPreserve;
                    impl ::metrique::concat::ConstStr for operationPreserve {
                        const VAL: &'static str = "operation";
                    }
                    #[allow(non_camel_case_types)]
                    struct operationKebab;
                    impl ::metrique::concat::ConstStr for operationKebab {
                        const VAL: &'static str = "operation";
                    }
                    #[allow(non_camel_case_types)]
                    struct operationPascal;
                    impl ::metrique::concat::ConstStr for operationPascal {
                        const VAL: &'static str = "Operation";
                    }
                    #[allow(non_camel_case_types)]
                    struct operationSnake;
                    impl ::metrique::concat::ConstStr for operationSnake {
                        const VAL: &'static str = "operation";
                    }
                    ::metrique::concat::const_str_value::<
                        <NS as ::metrique::NameStyle>::Inflect<
                            operationPreserve,
                            operationPascal,
                            operationSnake,
                            operationKebab,
                        >,
                    >()
                },
                &self.operation,
            );
            ::metrique::writer::EntryWriter::value(
                writer,
                {
                    #[allow(non_camel_case_types)]
                    struct request_idPreserve;
                    impl ::metrique::concat::ConstStr for request_idPreserve {
                        const VAL: &'static str = "request_id";
                    }
                    #[allow(non_camel_case_types)]
                    struct request_idKebab;
                    impl ::metrique::concat::ConstStr for request_idKebab {
                        const VAL: &'static str = "request-id";
                    }
                    #[allow(non_camel_case_types)]
                    struct request_idPascal;
                    impl ::metrique::concat::ConstStr for request_idPascal {
                        const VAL: &'static str = "RequestId";
                    }
                    #[allow(non_camel_case_types)]
                    struct request_idSnake;
                    impl ::metrique::concat::ConstStr for request_idSnake {
                        const VAL: &'static str = "request_id";
                    }
                    ::metrique::concat::const_str_value::<
                        <NS as ::metrique::NameStyle>::Inflect<
                            request_idPreserve,
                            request_idPascal,
                            request_idSnake,
                            request_idKebab,
                        >,
                    >()
                },
                &self.request_id,
            );
        }
        fn sample_group(
            &self,
        ) -> impl ::std::iter::Iterator<
            Item = (::std::borrow::Cow<'static, str>, ::std::borrow::Cow<'static, str>),
        > {
            {
                #[allow(non_camel_case_types)]
                struct operationPreserve;
                impl ::metrique::concat::ConstStr for operationPreserve {
                    const VAL: &'static str = "operation";
                }
                #[allow(non_camel_case_types)]
                struct operationKebab;
                impl ::metrique::concat::ConstStr for operationKebab {
                    const VAL: &'static str = "operation";
                }
                #[allow(non_camel_case_types)]
                struct operationPascal;
                impl ::metrique::concat::ConstStr for operationPascal {
                    const VAL: &'static str = "Operation";
                }
                #[allow(non_camel_case_types)]
                struct operationSnake;
                impl ::metrique::concat::ConstStr for operationSnake {
                    const VAL: &'static str = "operation";
                }
                ::std::iter::once((
                    ::metrique::concat::const_str_value::<
                        <NS as ::metrique::NameStyle>::Inflect<
                            operationPreserve,
                            operationPascal,
                            operationSnake,
                            operationKebab,
                        >,
                    >(),
                    ::metrique::writer::core::SampleGroup::as_sample_group(
                        &self.operation,
                    ),
                ))
            }
        }
    }
};
impl metrique::CloseValue for &'_ Metadata {
    type Closed = MetadataEntry;
    fn close(self) -> Self::Closed {
        #[allow(deprecated)]
        MetadataEntry {
            operation: metrique::CloseValue::close(&self.operation),
            request_id: metrique::CloseValue::close(&self.request_id),
        }
    }
}
impl metrique::CloseValue for Metadata {
    type Closed = MetadataEntry;
    fn close(self) -> Self::Closed {
        <&Self>::close(&self)
    }
}

enum RequestResult {
    Success { operation: Operation, bytes: usize },
    Error { operation: Operation, error_code: u32 },
    Timeout(Metadata),
    Cancelled(Metadata, StatusEntry),
}
#[doc(hidden)]
enum RequestResultEntry {
    #[deprecated(
        note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
    )]
    #[doc(hidden)]
    Success {
        #[deprecated(
            note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
        )]
        #[doc(hidden)]
        operation: <Operation as metrique::CloseValue>::Closed,
        #[deprecated(
            note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
        )]
        #[doc(hidden)]
        bytes: <usize as metrique::CloseValue>::Closed,
    },
    #[deprecated(
        note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
    )]
    #[doc(hidden)]
    Error {
        #[deprecated(
            note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
        )]
        #[doc(hidden)]
        operation: <Operation as metrique::CloseValue>::Closed,
        #[deprecated(
            note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
        )]
        #[doc(hidden)]
        error_code: <u32 as metrique::CloseValue>::Closed,
    },
    #[deprecated(
        note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
    )]
    #[doc(hidden)]
    Timeout(<Metadata as metrique::CloseValue>::Closed),
    #[deprecated(
        note = "these fields will become private in a future release. To introspect an entry, use `metrique::writer::test_util::test_entry`"
    )]
    #[doc(hidden)]
    Cancelled(<Metadata as metrique::CloseValue>::Closed, StatusEntry),
}
const _: () = {
    enum RequestResultEntrySampleGroupIter<V0, V1, V2, V3> {
        V0(V0),
        V1(V1),
        V2(V2),
        V3(V3),
    }
    impl<
        V0: ::std::iter::Iterator<
                Item = (
                    ::std::borrow::Cow<'static, str>,
                    ::std::borrow::Cow<'static, str>,
                ),
            >,
        V1: ::std::iter::Iterator<
                Item = (
                    ::std::borrow::Cow<'static, str>,
                    ::std::borrow::Cow<'static, str>,
                ),
            >,
        V2: ::std::iter::Iterator<
                Item = (
                    ::std::borrow::Cow<'static, str>,
                    ::std::borrow::Cow<'static, str>,
                ),
            >,
        V3: ::std::iter::Iterator<
                Item = (
                    ::std::borrow::Cow<'static, str>,
                    ::std::borrow::Cow<'static, str>,
                ),
            >,
    > ::std::iter::Iterator for RequestResultEntrySampleGroupIter<V0, V1, V2, V3> {
        type Item = (::std::borrow::Cow<'static, str>, ::std::borrow::Cow<'static, str>);
        fn next(&mut self) -> ::std::option::Option<Self::Item> {
            match self {
                RequestResultEntrySampleGroupIter::V0(iter) => iter.next(),
                RequestResultEntrySampleGroupIter::V1(iter) => iter.next(),
                RequestResultEntrySampleGroupIter::V2(iter) => iter.next(),
                RequestResultEntrySampleGroupIter::V3(iter) => iter.next(),
            }
        }
    }
    #[expect(deprecated)]
    impl<NS: ::metrique::NameStyle> ::metrique::InflectableEntry<NS>
    for RequestResultEntry {
        fn write<'a>(&'a self, writer: &mut impl ::metrique::writer::EntryWriter<'a>) {
            #[allow(deprecated)]
            match self {
                RequestResultEntry::Success { operation, bytes } => {
                    ::metrique::writer::EntryWriter::value(
                        writer,
                        {
                            #[allow(non_camel_case_types)]
                            struct operationPreserve;
                            impl ::metrique::concat::ConstStr for operationPreserve {
                                const VAL: &'static str = "operation";
                            }
                            #[allow(non_camel_case_types)]
                            struct operationKebab;
                            impl ::metrique::concat::ConstStr for operationKebab {
                                const VAL: &'static str = "operation";
                            }
                            #[allow(non_camel_case_types)]
                            struct operationPascal;
                            impl ::metrique::concat::ConstStr for operationPascal {
                                const VAL: &'static str = "Operation";
                            }
                            #[allow(non_camel_case_types)]
                            struct operationSnake;
                            impl ::metrique::concat::ConstStr for operationSnake {
                                const VAL: &'static str = "operation";
                            }
                            ::metrique::concat::const_str_value::<
                                <NS as ::metrique::NameStyle>::Inflect<
                                    operationPreserve,
                                    operationPascal,
                                    operationSnake,
                                    operationKebab,
                                >,
                            >()
                        },
                        operation,
                    );
                    ::metrique::writer::EntryWriter::value(
                        writer,
                        {
                            #[allow(non_camel_case_types)]
                            struct bytesPreserve;
                            impl ::metrique::concat::ConstStr for bytesPreserve {
                                const VAL: &'static str = "bytes";
                            }
                            #[allow(non_camel_case_types)]
                            struct bytesKebab;
                            impl ::metrique::concat::ConstStr for bytesKebab {
                                const VAL: &'static str = "bytes";
                            }
                            #[allow(non_camel_case_types)]
                            struct bytesPascal;
                            impl ::metrique::concat::ConstStr for bytesPascal {
                                const VAL: &'static str = "Bytes";
                            }
                            #[allow(non_camel_case_types)]
                            struct bytesSnake;
                            impl ::metrique::concat::ConstStr for bytesSnake {
                                const VAL: &'static str = "bytes";
                            }
                            ::metrique::concat::const_str_value::<
                                <NS as ::metrique::NameStyle>::Inflect<
                                    bytesPreserve,
                                    bytesPascal,
                                    bytesSnake,
                                    bytesKebab,
                                >,
                            >()
                        },
                        bytes,
                    );
                }
                RequestResultEntry::Error { operation, error_code } => {
                    ::metrique::writer::EntryWriter::value(
                        writer,
                        {
                            #[allow(non_camel_case_types)]
                            struct operationPreserve;
                            impl ::metrique::concat::ConstStr for operationPreserve {
                                const VAL: &'static str = "operation";
                            }
                            #[allow(non_camel_case_types)]
                            struct operationKebab;
                            impl ::metrique::concat::ConstStr for operationKebab {
                                const VAL: &'static str = "operation";
                            }
                            #[allow(non_camel_case_types)]
                            struct operationPascal;
                            impl ::metrique::concat::ConstStr for operationPascal {
                                const VAL: &'static str = "Operation";
                            }
                            #[allow(non_camel_case_types)]
                            struct operationSnake;
                            impl ::metrique::concat::ConstStr for operationSnake {
                                const VAL: &'static str = "operation";
                            }
                            ::metrique::concat::const_str_value::<
                                <NS as ::metrique::NameStyle>::Inflect<
                                    operationPreserve,
                                    operationPascal,
                                    operationSnake,
                                    operationKebab,
                                >,
                            >()
                        },
                        operation,
                    );
                    ::metrique::writer::EntryWriter::value(
                        writer,
                        {
                            #[allow(non_camel_case_types)]
                            struct error_codePreserve;
                            impl ::metrique::concat::ConstStr for error_codePreserve {
                                const VAL: &'static str = "error_code";
                            }
                            #[allow(non_camel_case_types)]
                            struct error_codeKebab;
                            impl ::metrique::concat::ConstStr for error_codeKebab {
                                const VAL: &'static str = "error-code";
                            }
                            #[allow(non_camel_case_types)]
                            struct error_codePascal;
                            impl ::metrique::concat::ConstStr for error_codePascal {
                                const VAL: &'static str = "ErrorCode";
                            }
                            #[allow(non_camel_case_types)]
                            struct error_codeSnake;
                            impl ::metrique::concat::ConstStr for error_codeSnake {
                                const VAL: &'static str = "error_code";
                            }
                            ::metrique::concat::const_str_value::<
                                <NS as ::metrique::NameStyle>::Inflect<
                                    error_codePreserve,
                                    error_codePascal,
                                    error_codeSnake,
                                    error_codeKebab,
                                >,
                            >()
                        },
                        error_code,
                    );
                }
                RequestResultEntry::Timeout(v0) => {
                    ::metrique::InflectableEntry::<NS>::write(v0, writer);
                }
                RequestResultEntry::Cancelled(v0, v1) => {
                    ::metrique::InflectableEntry::<NS>::write(v0, writer);
                    ::metrique::writer::Entry::write(v1, writer);
                }
            }
        }
        fn sample_group(
            &self,
        ) -> impl ::std::iter::Iterator<
            Item = (::std::borrow::Cow<'static, str>, ::std::borrow::Cow<'static, str>),
        > {
            match self {
                RequestResultEntry::Success { operation, .. } => {
                    RequestResultEntrySampleGroupIter::V0({
                        #[allow(non_camel_case_types)]
                        struct operationPreserve;
                        impl ::metrique::concat::ConstStr for operationPreserve {
                            const VAL: &'static str = "operation";
                        }
                        #[allow(non_camel_case_types)]
                        struct operationKebab;
                        impl ::metrique::concat::ConstStr for operationKebab {
                            const VAL: &'static str = "operation";
                        }
                        #[allow(non_camel_case_types)]
                        struct operationPascal;
                        impl ::metrique::concat::ConstStr for operationPascal {
                            const VAL: &'static str = "Operation";
                        }
                        #[allow(non_camel_case_types)]
                        struct operationSnake;
                        impl ::metrique::concat::ConstStr for operationSnake {
                            const VAL: &'static str = "operation";
                        }
                        ::std::iter::once((
                            ::metrique::concat::const_str_value::<
                                <NS as ::metrique::NameStyle>::Inflect<
                                    operationPreserve,
                                    operationPascal,
                                    operationSnake,
                                    operationKebab,
                                >,
                            >(),
                            ::metrique::writer::core::SampleGroup::as_sample_group(
                                operation,
                            ),
                        ))
                    })
                }
                RequestResultEntry::Error { operation, .. } => {
                    RequestResultEntrySampleGroupIter::V1({
                        #[allow(non_camel_case_types)]
                        struct operationPreserve;
                        impl ::metrique::concat::ConstStr for operationPreserve {
                            const VAL: &'static str = "operation";
                        }
                        #[allow(non_camel_case_types)]
                        struct operationKebab;
                        impl ::metrique::concat::ConstStr for operationKebab {
                            const VAL: &'static str = "operation";
                        }
                        #[allow(non_camel_case_types)]
                        struct operationPascal;
                        impl ::metrique::concat::ConstStr for operationPascal {
                            const VAL: &'static str = "Operation";
                        }
                        #[allow(non_camel_case_types)]
                        struct operationSnake;
                        impl ::metrique::concat::ConstStr for operationSnake {
                            const VAL: &'static str = "operation";
                        }
                        ::std::iter::once((
                            ::metrique::concat::const_str_value::<
                                <NS as ::metrique::NameStyle>::Inflect<
                                    operationPreserve,
                                    operationPascal,
                                    operationSnake,
                                    operationKebab,
                                >,
                            >(),
                            ::metrique::writer::core::SampleGroup::as_sample_group(
                                operation,
                            ),
                        ))
                    })
                }
                RequestResultEntry::Timeout(v0) => {
                    RequestResultEntrySampleGroupIter::V2(
                        ::metrique::InflectableEntry::<NS>::sample_group(v0),
                    )
                }
                RequestResultEntry::Cancelled(v0, v1) => {
                    RequestResultEntrySampleGroupIter::V3(
                        ::metrique::InflectableEntry::<NS>::sample_group(v0)
                            .chain(::metrique::writer::Entry::sample_group(v1)),
                    )
                }
            }
        }
    }
};
impl metrique::CloseValue for RequestResult {
    type Closed = RequestResultEntry;
    fn close(self) -> Self::Closed {
        #[allow(deprecated)]
        match self {
            RequestResult::Success { operation, bytes } => {
                RequestResultEntry::Success {
                    operation: metrique::CloseValue::close(operation),
                    bytes: metrique::CloseValue::close(bytes),
                }
            }
            RequestResult::Error { operation, error_code } => {
                RequestResultEntry::Error {
                    operation: metrique::CloseValue::close(operation),
                    error_code: metrique::CloseValue::close(error_code),
                }
            }
            RequestResult::Timeout(v0) => {
                RequestResultEntry::Timeout(::metrique::CloseValue::close(v0))
            }
            RequestResult::Cancelled(v0, v1) => {
                RequestResultEntry::Cancelled(::metrique::CloseValue::close(v0), v1)
            }
        }
    }
}
impl ::std::convert::From<&'_ RequestResult> for &'static str {
    fn from(value: &RequestResult) -> Self {
        #[allow(deprecated)]
        match value {
            RequestResult::Success { .. } => "Success",
            RequestResult::Error { .. } => "Error",
            RequestResult::Timeout(_) => "Timeout",
            RequestResult::Cancelled(_, _) => "Cancelled",
        }
    }
}
impl ::std::convert::From<RequestResult> for &'static str {
    fn from(value: RequestResult) -> Self {
        <&str as ::std::convert::From<&_>>::from(&value)
    }
}
impl ::metrique::writer::core::SampleGroup for RequestResult {
    fn as_sample_group(&self) -> ::std::borrow::Cow<'static, str> {
        ::std::borrow::Cow::Borrowed(::std::convert::Into::<&str>::into(self))
    }
}
#[doc = concat!(
    "Metrics guard returned from [`", "RequestResult",
    "::append_on_drop`], closes the entry and appends the metrics to a sink when dropped."
)]
type RequestResultGuard<Q = ::metrique::DefaultSink> = ::metrique::AppendAndCloseOnDrop<
    RequestResult,
    Q,
>;
#[doc = concat!(
    "Metrics handle returned from [`", "RequestResultGuard",
    "::handle`], similar to an `Arc<", "RequestResultGuard", ">`."
)]
type RequestResultHandle<Q = ::metrique::DefaultSink> = ::metrique::AppendAndCloseOnDropHandle<
    RequestResult,
    Q,
>;
impl RequestResult {
    ///Creates an AppendAndCloseOnDrop that will be automatically appended to `sink` on drop.
    fn append_on_drop<
        Q: ::metrique::writer::EntrySink<::metrique::RootEntry<RequestResultEntry>>
            + Send + Sync + 'static,
    >(self, sink: Q) -> RequestResultGuard<Q> {
        ::metrique::append_and_close(self, sink)
    }
}
